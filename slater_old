/*! \file
    \ingroup DETCI
    \brief Enter brief description of file here 
*/

/* Slater Determinant Class
**
** Based on a previous implementation by David Sherrill using bitsrings 
** from the g++ library and on a symbolic Slater's rules program written
** in C by Matt Leininger
**
** February 7, 1996
**
** C. David Sherrill and Matthew L. Leininger
** Center for Computational Quantum Chemistry
** University of Georgia
** Athens, GA 30606
** 
** Need to #include <cstdio> before this file
**
** Assume number of alpha electrons is greater than or equal to the number
** of beta electrons
**
** Currently matrix_element() uses static temp arrays which are never free'd.
** The arrays should always be small, so this shouldn't be a problem.  The
** malloc'ing is only done once, no matter how many times matrix_element is
** called.
*/

#define PRINT_INTS =1
#ifndef _psi_plugins_variational_decomp_fci_slaterd_h
#define _psi_plugins_variational_decomp_fci_slaterd_h
//#ifndef _psi_src_bin_detci_slaterd_h
//#define _psi_src_bin_detci_slaterd_h

#include "permute.h"
namespace psi { namespace variational_decomp_fci {

class SlaterDeterminant {

   protected:
      unsigned nalp;
      unsigned nbet;
      unsigned char *Occs[2];

   public:
      SlaterDeterminant() { nalp=0; nbet=0; Occs[0]=NULL; Occs[1]=NULL; }
      ~SlaterDeterminant() { 
         if (Occs[0] != NULL) free(Occs[0]);
         if (Occs[1] != NULL) free(Occs[1]);
         }
      void set(unsigned int nalp, unsigned char *alpoccs, 
         unsigned int nbet, unsigned char *betoccs);
      void print(void);
      void print(FILE *outfile);
      void print_config(FILE *outfile) ;
      SlaterDeterminant& operator=(const SlaterDeterminant& s) ;
      friend int operator==(SlaterDeterminant& s1, SlaterDeterminant& s2) ;
      friend double matrix_element(SlaterDeterminant* I, SlaterDeterminant* J, double **Smo, double *pqrsINT, int nmo);
};
double H_matrix_element(int row_index, int col_index, int alphae, int betae, int nmo, double **mo_OEI, double *mo_TEI);
double matrix_element(SlaterDeterminant* I, SlaterDeterminant* J, double **mo_OEI, double *mo_TEI, int nmo);
double build_single_Hamiltonian_element(int row, int col, double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo);
void truncate_Hamiltonian(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo, const char * molname, const char * basisname);
void build_truncated_Hamiltonian(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo, const char * molname, const char * basisname);
void sort_Hamiltonian_diagonal(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo, const char * molname, const char * basisname);
void build_full_Hamiltonian(double **H, double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo);
void diagonalize_full_Hamiltonian(double **H, int alphae, int betae, int nmo,int print_option);
double get_onel(int i, int j, double **mo_OEI);
double get_twoel(int i, int j, int k, int l,double *mo_TEI, int nmo);
int calc_orb_diff(int cnt, unsigned char *I, unsigned char *J, 
   int *I_alpha_diff, int *J_alpha_diff, int *sign, int *same, 
   int extended);
void common_orbs(int *same_alpha, int *same_beta, int cnt_alpha,
   int cnt_beta, int *common_docc, int *common_alpha_socc, 
   int *common_beta_socc, int *cnt_docc, int *cnt_alpha_socc, 
   int *cnt_beta_socc);

/* The following functions have been taken from the DETCI package in psi3. Some of their functionality is contained in the slater header files */
void SlaterDeterminant::set(unsigned int na, unsigned char *alpoccs, 
      unsigned int nb, unsigned char *betoccs)
{
   int i;

   if (nalp != na) {
      if (Occs[0] != NULL) free(Occs[0]);
      Occs[0] = (unsigned char *) malloc (sizeof(unsigned char) * na); 
      nalp = na;
      }
   if (nbet != nb) {
      if (Occs[1] != NULL) free(Occs[1]);
      Occs[1] = (unsigned char *) malloc (sizeof(unsigned char) * nb);
      nbet = nb;
      }
   
   for (i=0; i<nalp; i++) {
      Occs[0][i] = alpoccs[i];
      }
   for (i=0; i<nbet; i++) {
      Occs[1][i] = betoccs[i];
      }
}



void SlaterDeterminant::print(void)
{
   print(stdout);
}



void SlaterDeterminant::print(FILE *outfile)
{
   int i;

   fprintf(outfile, "Alpha string: ");
   for (i=0; i<nalp; i++) {
      fprintf(outfile, "%3d ", Occs[0][i]);
      }
   fprintf(outfile, "\n");

   fprintf(outfile, "Beta string : ");
   for (i=0; i<nbet; i++) {
      fprintf(outfile, "%3d ", Occs[1][i]);
      }
   fprintf(outfile, "\n");
}


void SlaterDeterminant::print_config(FILE *outfile)
{
   int i=0, j=0;

   while ((i < nalp) && (j < nbet)) {
      if (Occs[0][i] == Occs[1][j]) {
         fprintf(outfile, "%dX ", Occs[0][i]+1);
         i++; j++;
         }
      else if (Occs[0][i] < Occs[1][j]) {
         fprintf(outfile, "%dA ", Occs[0][i]+1);
         i++;
         } 
      else if (Occs[0][i] > Occs[1][j]) {
         fprintf(outfile, "%dB ", Occs[1][j]+1);
         j++;
         }
      }

   if (i < j) {
      while (i < nalp) {
         fprintf(outfile, "%dA ", Occs[0][i]+1);
         i++;
         }
      }
   else if (i > j) {
      while (j < nbet) {
         fprintf(outfile, "%dB ", Occs[1][j]+1);
         j++;
         }
      }

   fprintf(outfile, "\n") ;

}


SlaterDeterminant& SlaterDeterminant::operator=(const SlaterDeterminant& s)
{
   if (nalp != s.nalp) {
      if (Occs[0] != NULL) free(Occs[0]);
      Occs[0] = (unsigned char *) malloc (sizeof(unsigned char) * s.nalp);   
      }   
   if (nbet != s.nbet) {
      if (Occs[1] != NULL) free(Occs[1]);
      Occs[1] = (unsigned char *) malloc (sizeof(unsigned char) * s.nbet);
      }
   set(s.nalp, s.Occs[0], s.nbet, s.Occs[1]);
   return(*this);
}


int operator ==(SlaterDeterminant& s1, SlaterDeterminant& s2) 
{
   int i;

   if (s1.nalp != s2.nalp || s1.nbet != s2.nbet) return(0);

   for (i=0; i<s1.nalp; i++) {
      if (s1.Occs[0][i] != s2.Occs[0][i]) return(0);
      }
   for (i=0; i<s1.nbet; i++) {
      if (s1.Occs[1][i] != s2.Occs[1][i]) return(0);
      }

   return(1);
}
   

/*double matrix_element(SlaterDeterminant* I, SlaterDeterminant* J, double **mo_OEI, double *mo_TEI, int nmo)
{
   static int first_call = 1;
   static int *same_alpha;
   static int *same_beta;
   static int *common_docc;
   static int *common_alp_socc;
   static int *common_bet_socc;
   static int init_nalp, init_nbet;
   static int **I_diff,**J_diff;
   int *common_socc1, *common_socc2;
   int sign=0;
   int nalp, nbet, nalp_same, nbet_same;
   int cnt_docc=0, cnt_alp_socc=0, cnt_bet_socc=0;
   int total_diff=-4, alpha_diff=-2, beta_diff=-2;
   int diffspin, samespin, common1, common2;
   int i, j, k, l, a, b, m;
   double val = 0.0;
   if (I->nalp != J->nalp || I->nbet != J->nbet) {
      fprintf(stderr,"(matrix_element): unequal length alp/bet strings!\n");
      return(0.0);
      }

   nalp = I->nalp; 
   nbet = I->nbet;

   if (first_call) {
      same_alpha = (int *) malloc(sizeof(int) * nalp);
      same_beta = (int *) malloc(sizeof(int) * nbet);
      common_alp_socc = (int *) malloc(sizeof(int) * nalp);
      common_bet_socc = (int *) malloc(sizeof(int) * nbet);
      common_docc = (int *) malloc(sizeof(int) * nalp); 
      I_diff = (int **) malloc(sizeof(int *) * 2);
      I_diff[0] = (int *) malloc(sizeof(int) * nalp);
      I_diff[1] = (int *) malloc(sizeof(int) * nalp);
      J_diff = (int **) malloc(sizeof(int *) * 2);
      J_diff[0] = (int *) malloc(sizeof(int) * nalp);
      J_diff[1] = (int *) malloc(sizeof(int) * nalp);
      init_nalp = nalp;
      init_nbet = nbet;
      first_call = 0;
      }

   // make sure that subsequent calls don't change the number of alpha or
   // beta electrons without re-initializing the static arrays
   else {
      if ((nalp != init_nalp) || (nbet != init_nbet)) {
         fprintf(stderr, "(matrix_element): nalp/nbet != init_nalp/nbet\n");
         exit(1);
         }
      
      }

   alpha_diff = calc_orb_diff(nalp, I->Occs[0], J->Occs[0], I_diff[0],
      J_diff[0], &sign, same_alpha, 0);
   beta_diff = calc_orb_diff(nbet, I->Occs[1], J->Occs[1], I_diff[1],
      J_diff[1], &sign, same_beta, 0);

   total_diff = alpha_diff + beta_diff ;
   nalp_same = nalp - alpha_diff ;
   nbet_same = nbet - beta_diff ;

   #ifdef DEBUG
   printf(" alpha_diff = %d\n", alpha_diff) ;
   printf(" beta_diff = %d\n", beta_diff) ;
   printf(" total_diff = %d\n", total_diff) ;
   printf(" sign = %d\n", sign) ;

   for (i=0; i<alpha_diff; i++)
      printf(" I_diff[0][%d] = %d ", i, I_diff[0][i]+1) ;
      printf("\n") ;
   for (i=0; i<alpha_diff; i++)
      printf(" J_diff[0][%d] = %d ", i, J_diff[0][i]+1) ;
      printf("\n\n") ;

   for (i=0; i<beta_diff; i++)
      printf(" I_diff[1][%d] = %d ", i, I_diff[1][i]+1) ;
      printf("\n") ;
   for (i=0; i<beta_diff; i++)
      printf(" J_diff[1][%d] = %d ", i, J_diff[1][i]+1) ;
      printf("\n\n") ;
   for (i=0; i<nalp_same; i++)
      printf(" same_alpha[%d] = %d", i, same_alpha[i]+1) ;
      printf("\n\n") ;
   for (i=0; i<nbet_same; i++)
      printf(" same_beta[%d] = %d", i, same_beta[i]+1) ;
      printf("\n\n") ;
   #endif

   if ((alpha_diff == -2) || (beta_diff == -2)) {
      fprintf(stderr, "(matrix_element): Problem with calc_orb_diff.\n");
      fprintf(stderr, "  Returns -2 value. \n");
      } 

   else if ((alpha_diff == -1) || (beta_diff == -1) || total_diff > 2) {
      return(0.0);
      }

   else if (total_diff == 2) {
      
      if (alpha_diff == 1) {      Case 1: 1 in alpha and 1 in beta 

         i = I_diff[0][0];
         j = I_diff[1][0];
         k = J_diff[0][0];
         l = J_diff[1][0];
         
         #ifdef PRINT_INTS
         //if (sign % 2) printf("-"); 
         #endif

         val = get_twoel(i,k,j,l,mo_TEI,nmo);
         if (sign % 2) val = -val;

         return(val); 
         }
      else if ((alpha_diff == 2) || (beta_diff == 2)) { 
         if (alpha_diff == 2)
            diffspin = 0; 
         else diffspin = 1;

         i = I_diff[diffspin][0];
         j = I_diff[diffspin][1];
         k = J_diff[diffspin][0];
         l = J_diff[diffspin][1]; 

         #ifdef PRINT_INTS
        // if (sign % 2) printf("- [ "); 
         #endif

         val = get_twoel(i,k,j,l,mo_TEI,nmo);
         val -= get_twoel(i,l,j,k,mo_TEI,nmo);

         #ifdef PRINT_INTS
         //if (sign % 2) printf(" ] "); 
         #endif
         
         if (sign % 2) val = -val;
 
         return(val);
}
      else {
         fprintf(stderr, "Error (matrix_element): total_diff != alpha_diff ");
         fprintf(stderr, "+ beta_diff\n");
         exit(1);
         }
 
      } 

   else if (total_diff == 1) {
   
      common_orbs(same_alpha, same_beta, nalp_same, nbet_same, common_docc,
         common_alp_socc, common_bet_socc, &cnt_docc, &cnt_alp_socc, 
         &cnt_bet_socc); 
 
      #ifdef DEBUG
      printf("cnt_docc = %d\n", cnt_docc); 
      printf("cnt_alp_socc = %d\n", cnt_alp_socc); 
      printf("cnt_bet_socc = %d\n", cnt_bet_socc); 

      for (i=0; i<cnt_docc; i++)
         printf("common_docc[%d] = %d\n", i, common_docc[i]+1) ; 
         printf("\n") ; 
      for (i=0; i<cnt_alp_socc; i++)
         printf("common_alp_socc[%d] = %d\n", i, common_alp_socc[i]+1) ; 
         printf("\n") ; 
      for (i=0; i<cnt_bet_socc; i++)
         printf("common_bet_socc[%d] = %d\n", i, common_bet_socc[i]+1) ;
         printf("\n") ; 
      #endif

      if (alpha_diff == 1) {          diffspin = 0; 
         samespin = 1; 
         common1 = cnt_alp_socc; 
         common2 = cnt_bet_socc; 
         common_socc1 = common_alp_socc; 
         common_socc2 = common_bet_socc; 
         }
      else if (beta_diff == 1) {          diffspin = 1;
         samespin = 0;
         common1 = cnt_bet_socc; 
         common2 = cnt_alp_socc; 
         common_socc1 = common_bet_socc; 
         common_socc2 = common_alp_socc; 
         } 
      else {
         fprintf(stderr, "(matrix_element): impossible case abdiff\n");
         exit(0);
         }

      i = I_diff[diffspin][0];
      j = J_diff[diffspin][0];

      val = get_onel(i,j,mo_OEI);

      #ifdef PRINT_INTS
      //if (sign % 2) 
        // printf(" - [ \n");
      #endif

      for (b=0; b<cnt_docc; b++) {          m = common_docc[b];

         #ifdef PRINT_INTS
         //printf("2 * ");
         #endif

         val += 2.0 * get_twoel(i,j,m,m,mo_TEI,nmo);
        
         #ifdef PRINT_INTS
        // printf("-");
         #endif 

         val -= get_twoel(i,m,m,j,mo_TEI,nmo);
         }      for (b=0; b<common2; b++) {         m = common_socc2[b];
         val += get_twoel(i,j,m,m,mo_TEI,nmo);
         }          

      for (b=0; b<common1; b++) {         m = common_socc1[b];

         val += get_twoel(i,j,m,m,mo_TEI,nmo);
        
         #ifdef PRINT_INTS
         //printf("-");
         #endif

         val -= get_twoel(i,m,m,j,mo_TEI,nmo);
         }

      if (sign % 2) val = -val;

      #ifdef PRINT_INTS
      //if (sign % 2) 
         //printf(" ] \n");
      #endif

      return(val);



   else if (total_diff == 0) { 

      common_orbs(same_alpha, same_beta, nalp_same, nbet_same, common_docc,
         common_alp_socc, common_bet_socc, &cnt_docc, &cnt_alp_socc,
         &cnt_bet_socc); 
     
      val = 0.0;

      //if (sign % 2) printf("- [ \n");
      //printf(" 2 * [ ");


      for (b=0; b<cnt_docc; b++) {    
         m = common_docc[b];
         val += 2.0 * get_onel(m,m,mo_OEI);
         }

      //printf(" ] ");

      for (b=0; b<cnt_alp_socc; b++) { 
         m = common_alp_socc[b];
         val += get_onel(m,m,mo_OEI);
         }

      for (b=0; b<cnt_bet_socc; b++) { 
         m = common_bet_socc[b];
         val += get_onel(m,m,mo_OEI);
         }

      #ifdef PRINT_INTS
      //printf("\n");
      #endif


      for (a=0; a<cnt_docc; a++) { 
         i = common_docc[a];

         for (b=0; b<cnt_alp_socc; b++) { 
            j = common_alp_socc[b];
            
            //printf("2 * ");

            val += 2.0 * get_twoel(i,i,j,j,mo_TEI,nmo);      

            //printf("- ");

            val -= get_twoel(i,j,i,j,mo_TEI,nmo); 
            }

         for (b=0; b<cnt_bet_socc; b++) {
            j = common_bet_socc[b];

           // printf("2 * ");

            val += 2.0 * get_twoel(i,i,j,j,mo_TEI,nmo);      

           // printf("- ");

            val -= get_twoel(i,j,i,j,mo_TEI,nmo);
            }

         val += get_twoel(i,i,i,i,mo_TEI,nmo);

         for (b=a+1; b<cnt_docc; b++) {

            j = common_docc[b];

            //printf("4 * ");

            val += 4.0 * get_twoel(i,i,j,j,mo_TEI,nmo);

            //printf("- 2 * ");

            val -= 2.0 * get_twoel(i,j,j,i,mo_TEI,nmo);

         i = common_alp_socc[a];

         for (b=a+1; b<cnt_alp_socc; b++) {

            j = common_alp_socc[b];
            
            val += get_twoel(i,i,j,j,mo_TEI,nmo);

            //printf("- ");

            val -= get_twoel(i,j,j,i,mo_TEI,nmo);
            }

         for (b=0; b<cnt_bet_socc; b++) {
            j = common_bet_socc[b];
            val += get_twoel(i,i,j,j,mo_TEI,nmo);
            }
         }


      for (a=0; a<cnt_bet_socc; a++) {
         for (b=a+1; b<cnt_bet_socc; b++) {

            i = common_bet_socc[a];
            j = common_bet_socc[b];
            
            val += get_twoel(i,i,j,j,mo_TEI,nmo);

           // printf("- ");

            val -= get_twoel(i,j,j,i,mo_TEI,nmo);
            }
         }

      if (sign % 2) val = -val;

      //if (sign % 2) 
         //printf(" ] \n");

      return(val);


   else {
      fprintf(stderr, "(matrix_element): Impossible case for total_diff!  \n");
      exit(1);
      }

   return(val);
}*/
/* End files taken from DETCI */

double build_single_Hamiltonian_element(int row, int col, double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	int N = astringcount*bstringcount;
	//strings of occupied determinants for a, b electrons
	unsigned char astringR[alphae], astringC[alphae], bstringR[betae], bstringC[betae];
	SlaterDeterminant Row;
	SlaterDeterminant Col;
	for(int i=0;i<alphae;i++){
		astringR[i]=i;
	}
	for(int i=0;i<betae;i++){
		bstringR[i]=i;
	}
	int * indexR = init_int_array(2);
	//increment index up to appropriate level of excitation for a or b in row determinant
	for(int r_index=0;r_index<row;r_index++){ //indexes string row
		indexR[1]++;
		if(indexR[1]==astringcount){
			indexR[1]=0;
			indexR[0]++;
		}
	}
	//compute next combination for a and b
	for(int comb=0;comb<indexR[0];comb++){
		next_combination_char(astringR,nmo,alphae);
	}
	for(int comb=0;comb<indexR[1];comb++){
		next_combination_char(bstringR,nmo,alphae);
	}
	free(indexR);
	Row.set(alphae,astringR,betae,bstringR);
	for(int i=0;i<alphae;i++){
		astringC[i]=i;
	}
	for(int i=0;i<betae;i++){
		bstringC[i]=i;
	}
	int * indexC = init_int_array(2);
	//increment index up to appropriate level of excitation for a or b in col determinant
	for(int c_index=0;c_index<col;c_index++){ //indexes col row
		indexC[1]++;
		if(indexC[1]==astringcount){
			indexC[1]=0;
			indexC[0]++;
		}

	}
	for(int comb=0;comb<indexC[0];comb++){
		next_combination_char(astringC,nmo,alphae);
	}
	for(int comb=0;comb<indexC[1];comb++){
		next_combination_char(bstringC,nmo,betae);
	}
			free(indexC);
	Col.set(alphae,astringC,betae,bstringC);
	//compute matrix element
	double val=matrix_element(&Row,&Col,mo_OEI,mo_TEI,nmo);
	//printf("%d %d %lf\n",row,col,val);
	return(val);

}

//computes all diagonal elements of H and sorts them up to the number of SV retained in the SV factorization scheme
void sort_Hamiltonian_diagonal(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo,const char * molname, const char * basisname){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	int factoredstringcount;
	if(astringcount==bstringcount||astringcount>bstringcount){
		factoredstringcount=astringcount;
	}
	else if(astringcount<bstringcount){
		factoredstringcount=bstringcount;
	}
	int N = astringcount*bstringcount;
	double *diag_vals=init_array(N);
	for(int i=0;i<N;i++){
		diag_vals[i]=build_single_Hamiltonian_element(i, i, mo_OEI, mo_TEI, alphae, betae, nmo);
	}
	double minimum;
	int min_pos;
	int *diag_sort=init_int_array(factoredstringcount);
	for(int i=0;i<factoredstringcount;i++){
		minimum=diag_vals[0];
		min_pos=0;
		for(int j=1;j<N;j++){
			if(diag_vals[j]<=minimum){
				minimum=diag_vals[j];
				min_pos=j;
				diag_sort[i]=j;
			}
		}
		diag_vals[min_pos]=10E100;
	}
	free(diag_vals);
	char diag_file[100];
	sprintf(diag_file,"factordiag/%s_%s_factordiag.o",molname,basisname);
	printf("%s\n",diag_file);
	FILE *diag_write=fopen(diag_file,"w");	
	for(int i=0;i<factoredstringcount;i++){
		fprintf(diag_write,"%d\n",diag_sort[i]);
	}
	fclose(diag_write);
	free(diag_sort);
}


//Builds full-size Hamiltonian explicitly according to Slater's rules
void build_full_Hamiltonian(double **H, double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	int N = astringcount*bstringcount;
	//strings of occupied determinants for a, b electrons
	unsigned char astringR[alphae], astringC[alphae], bstringR[betae], bstringC[betae];
	SlaterDeterminant Row;
	SlaterDeterminant Col;
	for(int row=0;row<N;row++){ //loop over H rows
		for(int i=0;i<alphae;i++){
			astringR[i]=i;
		}
		for(int i=0;i<betae;i++){
			bstringR[i]=i;
		}
		int * indexR = init_int_array(2);
		//increment index up to appropriate level of excitation for a or b in row determinant
		for(int r_index=0;r_index<row;r_index++){ //indexes string row
			indexR[1]++;
			if(indexR[1]==astringcount){
				indexR[1]=0;
				indexR[0]++;
			}
		}
		//compute next combination for a and b
		for(int comb=0;comb<indexR[0];comb++){
			next_combination_char(astringR,nmo,alphae);
		}
		for(int comb=0;comb<indexR[1];comb++){
			next_combination_char(bstringR,nmo,alphae);
		}
		free(indexR);
		Row.set(alphae,astringR,betae,bstringR);
		for(int col=0;col<N;col++){ //loop over H cols
			for(int i=0;i<alphae;i++){
				astringC[i]=i;
			}
			for(int i=0;i<betae;i++){
				bstringC[i]=i;
			}
			int * indexC = init_int_array(2);
			//increment index up to appropriate level of excitation for a or b in col determinant
			for(int c_index=0;c_index<col;c_index++){ //indexes col row
				indexC[1]++;
				if(indexC[1]==astringcount){
					indexC[1]=0;
					indexC[0]++;
				}

			}
			for(int comb=0;comb<indexC[0];comb++){
				next_combination_char(astringC,nmo,alphae);
			}
			for(int comb=0;comb<indexC[1];comb++){
				next_combination_char(bstringC,nmo,betae);
			}
					free(indexC);
			Col.set(alphae,astringC,betae,bstringC);
			//compute matrix element
			H[row][col]=matrix_element(&Row,&Col,mo_OEI,mo_TEI,nmo);
			//H[col][row]=H[row][col];
		}
	}

}

void write_full_Hamiltonian(double **H, double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	int N = astringcount*bstringcount;
	//strings of occupied determinants for a, b electrons
	unsigned char astringR[alphae], astringC[alphae], bstringR[betae], bstringC[betae];
	SlaterDeterminant Row;
	SlaterDeterminant Col;
	for(int row=0;row<N;row++){ //loop over H rows
		for(int i=0;i<alphae;i++){
			astringR[i]=i;
		}
		for(int i=0;i<betae;i++){
			bstringR[i]=i;
		}
		int * indexR = init_int_array(2);
		//increment index up to appropriate level of excitation for a or b in row determinant
		for(int r_index=0;r_index<row;r_index++){ //indexes string row
			indexR[1]++;
			if(indexR[1]==astringcount){
				indexR[1]=0;
				indexR[0]++;
			}
		}
		//compute next combination for a and b
		for(int comb=0;comb<indexR[0];comb++){
			next_combination_char(astringR,nmo,alphae);
		}
		for(int comb=0;comb<indexR[1];comb++){
			next_combination_char(bstringR,nmo,alphae);
		}
		free(indexR);
		Row.set(alphae,astringR,betae,bstringR);
		for(int col=0;col<N;col++){ //loop over H cols
			for(int i=0;i<alphae;i++){
				astringC[i]=i;
			}
			for(int i=0;i<betae;i++){
				bstringC[i]=i;
			}
			int * indexC = init_int_array(2);
			//increment index up to appropriate level of excitation for a or b in col determinant
			for(int c_index=0;c_index<col;c_index++){ //indexes col row
				indexC[1]++;
				if(indexC[1]==astringcount){
					indexC[1]=0;
					indexC[0]++;
				}

			}
			for(int comb=0;comb<indexC[0];comb++){
				next_combination_char(astringC,nmo,alphae);
			}
			for(int comb=0;comb<indexC[1];comb++){
				next_combination_char(bstringC,nmo,betae);
			}
					free(indexC);
			Col.set(alphae,astringC,betae,bstringC);
			//compute matrix element
			//H[row][col]=matrix_element(&Row,&Col,mo_OEI,mo_TEI,nmo);
			//fprintf(
		}
	}

}

//explicitly diagonalizes a full-size Hamiltonian. Set print_option = 1 to print all eigenvalues.
void diagonalize_full_Hamiltonian(double **H, int alphae, int betae, int nmo,int print_option){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	double *lambda=init_array(astringcount*bstringcount);
	double *work=init_array(10*astringcount*bstringcount);
	C_DSYEV('N','U',astringcount*bstringcount,H[0],astringcount*bstringcount,lambda,work,10*astringcount*bstringcount);
	if(print_option==1){
		for(int i=0;i<astringcount*bstringcount;i++){
			printf("%d %20.14lf\n",i,lambda[i]);
		}
	}
	if(print_option==2){
		printf("0 %20.14lf\n",lambda[0]);
	}
	free(lambda);
	free(work);
}

void build_truncated_Hamiltonian(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo, const char * molname, const char * basisname){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	char filename[100];
	char line[80];
	sprintf(filename,"factordiag/%s_%s_factordiag.o",molname,basisname);
	FILE * diag_file=fopen(filename,"r");
	int * diag_sort=init_int_array(astringcount);
	//double ** full_Happ=block_matrix(astringcount,astringcount);
	double ** full_Happ=block_matrix(astringcount*bstringcount,astringcount*bstringcount);
	/*while(fscanf(diag_file,"%s",line)!=EOF){ //read column into vector
			sscanf(line,"%le",&cvec[j]);
			j++;
			index+=4;
		}
			i++;
		}
		fclose(cfile);
	}*/
	int indx=0;
	while(fscanf(diag_file,"%d",&diag_sort[indx])!=EOF){
		indx++;
	}
	fclose(diag_file);
	for(int i=0;i<astringcount;i++){
		//printf("%d\n",diag_sort[i]);
	}
	sprintf(filename,"truncated_hamiltonian/%s_%s_truncH.o",molname,basisname);
	FILE * H_file = fopen(filename,"w");
	for(int i=0;i<astringcount*bstringcount;i++){
		for(int j=0;j<astringcount*bstringcount;j++){
			printf("%d %d\n",i,j);
			//full_Happ[i][j]=build_single_Hamiltonian_element(diag_sort[i], diag_sort[j], mo_OEI, mo_TEI, alphae, betae, nmo);
			full_Happ[i][j]=build_single_Hamiltonian_element(i, j, mo_OEI, mo_TEI, alphae, betae, nmo);
	fprintf(H_file,"%20.14lf ",full_Happ[i][j]);
		}
		fprintf(H_file,"\n");
	}
	print_mat(full_Happ,astringcount,astringcount,outfile);
	free(diag_sort);
	free_block(full_Happ);
}

void truncate_Hamiltonian(double **mo_OEI, double *mo_TEI, int alphae, int betae, int nmo, const char * molname, const char * basisname){
	int astringcount=nchoosek(nmo,alphae);
	int bstringcount=nchoosek(nmo,betae);
	char filename[100];
	char line[80];
	sprintf(filename,"factordiag/%s_%s_factordiag.o",molname,basisname);
	FILE * diag_file=fopen(filename,"r");
	int * diag_sort=init_int_array(astringcount);
	double ** full_Happ=block_matrix(astringcount,astringcount);
	/*while(fscanf(diag_file,"%s",line)!=EOF){ //read column into vector
			sscanf(line,"%le",&cvec[j]);
			j++;
			index+=4;
		}
			i++;
		}
		fclose(cfile);
	}*/
	int indx=0;
	while(fscanf(diag_file,"%d",&diag_sort[indx])!=EOF){
		indx++;
	}
	fclose(diag_file);
	for(int i=0;i<astringcount;i++){
		//printf("%d\n",diag_sort[i]);
	}
	for(int i=0;i<astringcount;i++){
		for(int j=0;j<astringcount;j++){
			full_Happ[i][j]=build_single_Hamiltonian_element(diag_sort[i], diag_sort[j], mo_OEI, mo_TEI, alphae, betae, nmo);
		}
	}
	free(diag_sort);
	sprintf(filename,"truncate_diag/%s_%s_truncate.o",molname,basisname);
	printf("%s\n",filename);
	FILE * trunc_file;
	if(trunc_file=fopen(filename,"w")){
		//print_mat(full_Happ,astringcount,astringcount,outfile);
		for(int k=2;k<astringcount;k++){
			double *lambda=init_array(k);
			double *work=init_array(10*k);
			double ** Happ=block_matrix(k,k);
			for(int i=0;i<k;i++){
				for(int j=0;j<k;j++){
					Happ[i][j]=full_Happ[i][j];
				}
			}
			//print_mat(Happ,k,k,outfile);
			C_DSYEV('N','U',k,Happ[0],k,lambda,work,10*k);
			//if(k>=3){
				fprintf(trunc_file,"%d ",k);
				for(int i=0;i<5;i++){
					if(i<k){
						fprintf(trunc_file,"%20.14lf ",lambda[i]);
					}
					else{
						fprintf(trunc_file,"%20.14lf ",0.0);
					}
	
				}
				fprintf(trunc_file,"\n");
			//}
			free(lambda);
			free(work);
			free_block(Happ);
		}
		int k=astringcount;
		double *lambda=init_array(k);
		double *work=init_array(10*k);
		C_DSYEV('N','U',k,full_Happ[0],k,lambda,work,10*k);
		fprintf(trunc_file,"%d ",k);
		for(int i=0;i<5;i++){
			if(i<k){
				fprintf(trunc_file,"%20.14lf ",lambda[i]);
			}
			else{
				fprintf(trunc_file,"%20.14lf ",0.0);
			}
		}
		fprintf(trunc_file,"\n");
		fclose(trunc_file);
		free(lambda);
		free(work);
	}
	else{printf("File not found\n");}
	free_block(full_Happ);
}


//indexes TEI
double get_twoel(int i, int j, int k, int l,double *mo_TEI, int nmo)
{
   return(mo_TEI[i*nmo*nmo*nmo+j*nmo*nmo+k*nmo+l]);
}

//indexes OEI
double get_onel(int i, int j, double **mo_OEI)
{
   return(mo_OEI[i][j]);
}

/* More functions taken from DETCI */
int calc_orb_diff(int cnt, unsigned char *I, unsigned char *J, 
      int *I_alpha_diff, int *J_alpha_diff, int *sign, int *same, 
      int extended)
{
   register int i = 0; 
   register int j = 0; 
   register int k = 0; 
   int icnt = 0;  /* number of counts in I array */
   int jcnt = 0;  /* number of counts in J array */ 
   int flipI = 0; /* number of flips in I string to have max coincidence */ 
   int flipJ = 0; /* number of flips in J string to have max coincidence */ 
   int ndoI = 0; /* number of different orbitals in I string */ 
   int ndoJ = 0; /* number of different orbitals in J string */

   while ((i < cnt) && (j < cnt)) {

      if (I[i] == J[j]) {
         same[k] = (int) I[i]; 
         i++;
         j++; 
         k++;
         }

      else if (I[i] < J[j]) {
         I_alpha_diff[icnt++] = (int) I[i];
         flipI += i - ndoI; 
         ndoI++; 
         i++;
         if ( ((icnt + jcnt) > 4) && !extended) return(-1);
         } 

      else if (I[i] > J[j]) {
         J_alpha_diff[jcnt++] = (int) J[j];
         flipJ += j - ndoJ; 
         ndoJ++; 
         j++;
         if ( ((icnt + jcnt) > 4) && !extended) return(-1);
         }

      } /* end while loop */

   /* Matt: this used to be a bit different...is this version
    * actually faster?  Seemed better the other way but I dunno ..CDS */
   if (i != j) {
      if (i<j) {
        if ( ((j-i+icnt)>=3) && !extended) return(-1);
        while (i<cnt) {
          I_alpha_diff[icnt++] = (int) I[i];
          flipI += i - ndoI;
          ndoI++;
          i++;
          } 
       }
      else {
          if ( ((i-j+jcnt)>=3) && !extended) return(-1);
          while (j<cnt) {
            J_alpha_diff[jcnt++] = (int) J[j];
            flipJ += j - ndoJ;
            ndoJ++;
            j++;
            } 
        } 
      } /* end if (i != j) loop */

   *sign += flipI + flipJ; 

   return icnt;
/*
   if (icnt == 2)
      return 2; 
   else if (icnt == 1)
      return 1; 
   else
      return 0; 
*/ 

}



/*
** common_orbs()
**
** This function creates the arrays common_docc, common_alpha_socc,
** and common_beta_socc used in the Slater Determinant Class.
**
*/
void common_orbs(int *same_alpha, int *same_beta, int cnt_alpha, int cnt_beta,
            int *common_docc, int *common_alpha_socc, int *common_beta_socc,
            int *cnt_docc, int *cnt_alpha_socc, int *cnt_beta_socc)  
{
   int i = 0; 
   int j = 0; 
   int k = 0; 
 
   while ((i<cnt_alpha) && (j<cnt_beta)) { 

      if (same_alpha[i] == same_beta[j]) {
         common_docc[(*cnt_docc)++] = same_alpha[i]; 
         i++; 
         j++; 
         }
   
      else if (same_alpha[i] < same_beta[j]) {
         common_alpha_socc[(*cnt_alpha_socc)++] = same_alpha[i]; 
         i++; 
         } 

      else if (same_alpha[i] > same_beta[j]) {
         common_beta_socc[(*cnt_beta_socc)++] = same_beta[j]; 
         j++; 
         } 

      } /* end top while loop */

   while (i<cnt_alpha) {
      common_alpha_socc[(*cnt_alpha_socc)++] = same_alpha[i];
      i++; 
      } 

   while (j<cnt_beta) {
      common_beta_socc[(*cnt_beta_socc)++] = same_beta[j]; 
      j++; 
      }

} 

/* End DETCI */

//! Binomial coefficient n!/(k!*(n-k)!) [probably slow]
/*int nchoosek(int n, int k){
	//check that we are not choosing more objects than exist
        if(k>n){
            return 0;
        }
        
        int nfact=1;
	for(int i=n-k+1;i<n+1;i++){
		nfact*=i;
	}
	int kfact=1;
	for(int i=1;i<k+1;i++){
		kfact*=i;
	}
	
	int denom = nfact/kfact;
	return denom;
}*/


double matrix_element(SlaterDeterminant* I, SlaterDeterminant* J, double **mo_OEI, double *mo_TEI, int nmo)
{
   static int first_call = 1;
   static int *same_alpha;
   static int *same_beta;
   static int *common_docc;
   static int *common_alp_socc;
   static int *common_bet_socc;
   static int init_nalp, init_nbet;
   static int **I_diff,**J_diff;
   int *common_socc1, *common_socc2;
   int sign=0;
   int nalp, nbet, nalp_same, nbet_same;
   int cnt_docc=0, cnt_alp_socc=0, cnt_bet_socc=0;
   int total_diff=-4, alpha_diff=-2, beta_diff=-2;
   int diffspin, samespin, common1, common2;
   int i, j, k, l, a, b, m;
   double val = 0.0;
   if (I->nalp != J->nalp || I->nbet != J->nbet) {
      fprintf(stderr,"(matrix_element): unequal length alp/bet strings!\n");
      return(0.0);
      }

   nalp = I->nalp; 
   nbet = I->nbet;

   if (first_call) {
      same_alpha = (int *) malloc(sizeof(int) * nalp);
      same_beta = (int *) malloc(sizeof(int) * nbet);
      common_alp_socc = (int *) malloc(sizeof(int) * nalp);
      common_bet_socc = (int *) malloc(sizeof(int) * nbet);
      common_docc = (int *) malloc(sizeof(int) * nalp); 
      I_diff = (int **) malloc(sizeof(int *) * 2);
      I_diff[0] = (int *) malloc(sizeof(int) * nalp);
      I_diff[1] = (int *) malloc(sizeof(int) * nalp);
      J_diff = (int **) malloc(sizeof(int *) * 2);
      J_diff[0] = (int *) malloc(sizeof(int) * nalp);
      J_diff[1] = (int *) malloc(sizeof(int) * nalp);
      init_nalp = nalp;
      init_nbet = nbet;
      first_call = 0;
      }

   // make sure that subsequent calls don't change the number of alpha or
   // beta electrons without re-initializing the static arrays
   else {
      if ((nalp != init_nalp) || (nbet != init_nbet)) {
         fprintf(stderr, "(matrix_element): nalp/nbet != init_nalp/nbet\n");
         exit(1);
         }
      
      }

   alpha_diff = calc_orb_diff(nalp, I->Occs[0], J->Occs[0], I_diff[0],
      J_diff[0], &sign, same_alpha, 0);
   beta_diff = calc_orb_diff(nbet, I->Occs[1], J->Occs[1], I_diff[1],
      J_diff[1], &sign, same_beta, 0);

   total_diff = alpha_diff + beta_diff ;
   nalp_same = nalp - alpha_diff ;
   nbet_same = nbet - beta_diff ;

   #ifdef DEBUG
   printf(" alpha_diff = %d\n", alpha_diff) ;
   printf(" beta_diff = %d\n", beta_diff) ;
   printf(" total_diff = %d\n", total_diff) ;
   printf(" sign = %d\n", sign) ;

   for (i=0; i<alpha_diff; i++)
      printf(" I_diff[0][%d] = %d ", i, I_diff[0][i]+1) ;
      printf("\n") ;
   for (i=0; i<alpha_diff; i++)
      printf(" J_diff[0][%d] = %d ", i, J_diff[0][i]+1) ;
      printf("\n\n") ;

   for (i=0; i<beta_diff; i++)
      printf(" I_diff[1][%d] = %d ", i, I_diff[1][i]+1) ;
      printf("\n") ;
   for (i=0; i<beta_diff; i++)
      printf(" J_diff[1][%d] = %d ", i, J_diff[1][i]+1) ;
      printf("\n\n") ;
   for (i=0; i<nalp_same; i++)
      printf(" same_alpha[%d] = %d", i, same_alpha[i]+1) ;
      printf("\n\n") ;
   for (i=0; i<nbet_same; i++)
      printf(" same_beta[%d] = %d", i, same_beta[i]+1) ;
      printf("\n\n") ;
   #endif

   if ((alpha_diff == -2) || (beta_diff == -2)) {
      fprintf(stderr, "(matrix_element): Problem with calc_orb_diff.\n");
      fprintf(stderr, "  Returns -2 value. \n");
      } 

   else if ((alpha_diff == -1) || (beta_diff == -1) || total_diff > 2) {
      return(0.0);
      }

   else if (total_diff == 2) {
      
      if (alpha_diff == 1) {     /* Case 1: 1 in alpha and 1 in beta */

         /* assign i,j,k,l for <ij||kl> */
         i = I_diff[0][0];
         j = I_diff[1][0];
         k = J_diff[0][0];
         l = J_diff[1][0];
         
         #ifdef PRINT_INTS
         //if (sign % 2) printf("-"); 
         #endif

         val = get_twoel(i,k,j,l,mo_TEI,nmo);
         if (sign % 2) val = -val;

         return(val); 
         } /* end Case 1 */ 

      else if ((alpha_diff == 2) || (beta_diff == 2)) { /* Case 2: 2 in alpha */

         if (alpha_diff == 2)
            diffspin = 0; 
         else diffspin = 1;

         /* assign <ij||kl> */
         i = I_diff[diffspin][0];
         j = I_diff[diffspin][1];
         k = J_diff[diffspin][0];
         l = J_diff[diffspin][1]; 

         #ifdef PRINT_INTS
        // if (sign % 2) printf("- [ "); 
         #endif

         val = get_twoel(i,k,j,l,mo_TEI,nmo);
         val -= get_twoel(i,l,j,k,mo_TEI,nmo);

         #ifdef PRINT_INTS
         //if (sign % 2) printf(" ] "); 
         #endif
         
         if (sign % 2) val = -val;
 
         return(val);
         } /* end else if for differ by 2 in alpha or beta */

      else {
         fprintf(stderr, "Error (matrix_element): total_diff != alpha_diff ");
         fprintf(stderr, "+ beta_diff\n");
         exit(1);
         }
 
      } /* end else if for differ by 2 spin orbitals */


   /* Differ by 1 spin orbital */
   else if (total_diff == 1) {
   
      common_orbs(same_alpha, same_beta, nalp_same, nbet_same, common_docc,
         common_alp_socc, common_bet_socc, &cnt_docc, &cnt_alp_socc, 
         &cnt_bet_socc); 
 
      #ifdef DEBUG
      printf("cnt_docc = %d\n", cnt_docc); 
      printf("cnt_alp_socc = %d\n", cnt_alp_socc); 
      printf("cnt_bet_socc = %d\n", cnt_bet_socc); 

      for (i=0; i<cnt_docc; i++)
         printf("common_docc[%d] = %d\n", i, common_docc[i]+1) ; 
         printf("\n") ; 
      for (i=0; i<cnt_alp_socc; i++)
         printf("common_alp_socc[%d] = %d\n", i, common_alp_socc[i]+1) ; 
         printf("\n") ; 
      for (i=0; i<cnt_bet_socc; i++)
         printf("common_bet_socc[%d] = %d\n", i, common_bet_socc[i]+1) ;
         printf("\n") ; 
      #endif

      if (alpha_diff == 1) { /* Case 1: 1 in alpha */   
         diffspin = 0; 
         samespin = 1; 
         common1 = cnt_alp_socc; 
         common2 = cnt_bet_socc; 
         common_socc1 = common_alp_socc; 
         common_socc2 = common_bet_socc; 
         } /* end Case 1: 1 in alpha */

      else if (beta_diff == 1) { /* Case 1: 1 in beta */
         diffspin = 1;
         samespin = 0;
         common1 = cnt_bet_socc; 
         common2 = cnt_alp_socc; 
         common_socc1 = common_bet_socc; 
         common_socc2 = common_alp_socc; 
         } /* end Case 1: 1 in beta */

      else {
         fprintf(stderr, "(matrix_element): impossible case abdiff\n");
         exit(0);
         }

      i = I_diff[diffspin][0];
      j = J_diff[diffspin][0];

      val = get_onel(i,j,mo_OEI);

      #ifdef PRINT_INTS
      //if (sign % 2) 
        // printf(" - [ \n");
      #endif

      for (b=0; b<cnt_docc; b++) { /* looping over all common docc electrons. */
         m = common_docc[b];

         #ifdef PRINT_INTS
         //printf("2 * ");
         #endif

         val += 2.0 * get_twoel(i,j,m,m,mo_TEI,nmo);
        
         #ifdef PRINT_INTS
        // printf("-");
         #endif 

         val -= get_twoel(i,m,m,j,mo_TEI,nmo);
         } /* end loop over all common docc electrons */

      for (b=0; b<common2; b++) { /* looping over all beta or alpha elec.;
                                    beta if differs in one by alpha */
         m = common_socc2[b];
         val += get_twoel(i,j,m,m,mo_TEI,nmo);
         }          

      for (b=0; b<common1; b++) { /* looping over all alpha or beta elec.;
                                    alpha if differs in one by alpha */
         m = common_socc1[b];

         val += get_twoel(i,j,m,m,mo_TEI,nmo);
        
         #ifdef PRINT_INTS
         //printf("-");
         #endif

         val -= get_twoel(i,m,m,j,mo_TEI,nmo);
         }

      if (sign % 2) val = -val;

      #ifdef PRINT_INTS
      //if (sign % 2) 
         //printf(" ] \n");
      #endif

      return(val);

      } /* end if (total_diff == 1) for Case 1: Differ by 1 spin orbital */


   else if (total_diff == 0) { 

      common_orbs(same_alpha, same_beta, nalp_same, nbet_same, common_docc,
         common_alp_socc, common_bet_socc, &cnt_docc, &cnt_alp_socc,
         &cnt_bet_socc); 
     
      val = 0.0;

      //if (sign % 2) printf("- [ \n");
      //printf(" 2 * [ ");

      /* get one-electron integrals */

      for (b=0; b<cnt_docc; b++) {    
         m = common_docc[b];
         val += 2.0 * get_onel(m,m,mo_OEI);
         }

      //printf(" ] ");

      for (b=0; b<cnt_alp_socc; b++) { 
         m = common_alp_socc[b];
         val += get_onel(m,m,mo_OEI);
         }

      for (b=0; b<cnt_bet_socc; b++) { 
         m = common_bet_socc[b];
         val += get_onel(m,m,mo_OEI);
         }

      #ifdef PRINT_INTS
      //printf("\n");
      #endif

      /* get two-electron integrals */

      for (a=0; a<cnt_docc; a++) { 
         i = common_docc[a];

         for (b=0; b<cnt_alp_socc; b++) { 
            j = common_alp_socc[b];
            
            //printf("2 * ");

            val += 2.0 * get_twoel(i,i,j,j,mo_TEI,nmo);      

            //printf("- ");

            val -= get_twoel(i,j,i,j,mo_TEI,nmo); 
            }

         for (b=0; b<cnt_bet_socc; b++) {
            j = common_bet_socc[b];

           // printf("2 * ");

            val += 2.0 * get_twoel(i,i,j,j,mo_TEI,nmo);      

           // printf("- ");

            val -= get_twoel(i,j,i,j,mo_TEI,nmo);
            }

         val += get_twoel(i,i,i,i,mo_TEI,nmo);

         for (b=a+1; b<cnt_docc; b++) {

            j = common_docc[b];

            //printf("4 * ");

            val += 4.0 * get_twoel(i,i,j,j,mo_TEI,nmo);

            //printf("- 2 * ");

            val -= 2.0 * get_twoel(i,j,j,i,mo_TEI,nmo);

            } /* end loop over pairs of doccs */

         } /* end loop a over doccs */

      /* loop over unique pairs of alpha electrons and alpha with beta */
      for (a=0; a<cnt_alp_socc; a++) {

         i = common_alp_socc[a];

         for (b=a+1; b<cnt_alp_socc; b++) {

            j = common_alp_socc[b];
            
            val += get_twoel(i,i,j,j,mo_TEI,nmo);

            //printf("- ");

            val -= get_twoel(i,j,j,i,mo_TEI,nmo);
            }

         for (b=0; b<cnt_bet_socc; b++) {
            j = common_bet_socc[b];
            val += get_twoel(i,i,j,j,mo_TEI,nmo);
            }
         }


      /* loop over unique pairs of beta electrons */
      for (a=0; a<cnt_bet_socc; a++) {
         for (b=a+1; b<cnt_bet_socc; b++) {

            i = common_bet_socc[a];
            j = common_bet_socc[b];
            
            val += get_twoel(i,i,j,j,mo_TEI,nmo);

           // printf("- ");

            val -= get_twoel(i,j,j,i,mo_TEI,nmo);
            }
         }

      if (sign % 2) val = -val;

      //if (sign % 2) 
         //printf(" ] \n");

      return(val);

      } /* end total_diff == 0 case */

   else {
      fprintf(stderr, "(matrix_element): Impossible case for total_diff!  \n");
      exit(1);
      }

   return(val);
}

}} // namespace psi::detci

#endif // header guard
